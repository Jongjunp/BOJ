# 15998. 카카오 머니

# 문제 정의
> 이 문제는 유클리드 호제법과 모듈러 연산의 성질을 이용해 풀어야 하는 문제이다.
> 기본적으로 유클리드 호제법과 모듈러 연산 알고리즘이 중요하나, 문제에서 가능한 케이스가 여러 가지로 분류되기 때문에 각각의 케이스에 대해서 처리를 해주어야 한다.

# 문제 풀이
> 우선 문제 상황을 살펴보면 무지의 카카오 계좌에 입출금을 할 때, 발생할 수 있는 경우의 수는 다음과 같다.
1. 처음부터 계속해서 입금만 하는 경우
> 이 경우에는 결과값으로 항상 1이 와야한다.
2. 입출금이 반복되는 경우
> 이 경우는 각각의 입출금 경우에 따라 다시 경우가 나뉜다.
> 우선 입금의 경우에는 본 계좌에서 돈을 가져오지 않는다. 따라서 입금 금액에 따라 최소 거래 가능 금액의 액수가 바뀌지 않도록 처리해야 한다.
> 출금의 경우, 두 가지 경우가 있다.
> 첫 번째 경우는 기존 금액에서 출금액을 뺐을 때, 0 또는 양수가 되는 경우이다. 이 경우에는 본 계좌에서 돈을 출금할 필요가 없다. 따라서 최소 입금 가능 금액에는 영향을 주지 않는다.
> 두 번째 경우는 기존 금액에서 출금액을 뺐을 때, 음수가 되는 경우이다. 이 경우에는 본 계좌에서 최소 거래 가능 금액의 배수만큼 돈을 출금해 카카오 계좌의 잔액을 양수로 만들어야 한다. 이는 곧, $|a(i)+r(i-1)-b(i)| mod M = 0$ 의 관계를 해당 경우에 속하는 1 이상의 모든 $i$에 대해서 만족시킨다는 말과 같다.
> 따라서 문제의 핵심은 이 경우에 해당하는 입력들에 대해서 $|a(i)+r(i-1)-b(i)|$의 최대공약수를 구하는 문제가 된다. 단, 이 최대공약수는 $b(i)$보다 큰 값이어야 한다. 이보다 작은 값이 최대공약수라면 $b(i)$에 해당하는 금액이 카카오 계좌에 충전되기 전에 부족분을 채울 것이기 때문에 잔액이 $b(i)$에 도달할 수 없다. 따라서 이 조건을 만족시키지 못할 때, 결과값은 -1이 된다.
3. 출금만 이루어지는 경우
> 이 경우는 위의 2번 경우와 똑같이 고려해주면 된다.

> 마지막으로 연산 결과 자체가 잘못되었을 때는 반드시 결과값이 -1이 되어야 한다.
> 아래는 GCD를 계산하는 코드이다. 
``` cpp
long long gcd (long long a, long long b) {
    while (true) {
		long long c = a % b;
		if (c == 0) return b;
		a = b;
		b = c;
	}
}
```

# 주의할 점
> DP를 위한 2D array를 만들 때, 입력으로 주어진 범위까지만을 table의 index로 설정해서는 안된다. 이 같은 경우, index의 끝부분인 corner case에서 에러가 일어날 수 있기 때문에 주어진 입력 값 범위 전부를 다룰 수 있는 array를 만들어야 한다.