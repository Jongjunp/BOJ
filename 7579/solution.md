# 7579. 앱

# 문제 정의
> 이 문제는 0-1 knapsack의 변형된 문제이다.
> knapsack의 목표값을 비용이 아닌 메모리 해제량으로 삼는 아이디어가 필요하다.

# 문제 풀이
> 본 문제의 경우, knapsack 문제와 유사하게 풀되, knapsack을 위한 목표값을 비용이 아닌 메모리 해제량으로 삼아야 한다.
문제에서는 M 이상의 메모리 해제량을 가지도록 하는 앱 조합 중에서 최소 비용을 구하라고 말하고 있다. 하지만 반대로 생각하면 주어진 앱 중에서 N개를 골랐을 때, 해당 앱들을 해제하기 위한 비용이 최대가 되도록 하면서 그 때의 메모리 해제량이 M을 넘기는 최소 비용을 N을 증가시키면서 찾는 것과 같다.
> DP를 이용해 풀기 위해서 메모리 해제량을 값으로 가지는 이차원 배열 solution[101][10001]를 생성한다. 이 때, solution 배열의 index는 문제 조건에 따른 최대값으로 설정하였다.
> solution[n][c]의 의미는 앱 1~n 중에서 cost 합이 c 이하가 되도록 앱을 골랐을 때의 메모리 해제량이다. 앱 개수보다 작은 임의의 n에 대해서 아래 두 가지 경우 중, 메모리 해제량이 최대가 되도록 하는 선택을 해야한다.
> 1. maxValue(n)(c) = m_n + maxValue(n-1)(c-(c_n))
> 2. maxValue(n)(c) = maxValue(n-1)(c)
> maxValue(n)(c)를 구한 뒤에는 이를 M과 비교하여 M보다 메모리 해제량이 크고 이전까지의 최소 비용보다 c가 작다면 최소 비용을 c로 업데이트 한다.
> knapsack 구현 코드의 주요 부분은 다음과 같다.
``` cpp
int min_cost = COSTMAX;
    for (int i=0; i<N+1; i++) {
        for (int j=0; j<COSTMAX; j++) {
            if (i==0 || j==0) {
                solution[i][j] = 0;
            }
            else {
                if (j >= cost[i-1]) solution[i][j] = max(solution[i-1][j], solution[i-1][j-cost[i-1]]+memory[i-1]);
                else solution[i][j] = solution[i-1][j];
            }
            if (solution[i][j]>=M && j<min_cost) {
                min_cost = j;
            }
        }
    }
```

# 주의할 점
> 몇몇 문제에는 문제에 힌트가 주어져 있다. 본 문제에서 주어진 앱의 최대 개수와 메모리, 비용의 범위를 보면 앱의 최대 개수와 비용의 범위는 100으로 작은 반면 메모리의 범위는 천만으로 매우 큰 것을 볼 수 있다. 따라서 DP를 위해서는 앱의 개수와 비용을 사용해야 한다는 힌트를 얻을 수 있다.

